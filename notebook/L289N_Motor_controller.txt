Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2025-08-28T18:48:46+00:00

====== L289N Motor Controller ======
Created Thursday 28 August 2025

===== Overview =====
The L298N is a dual H-bridge motor driver that allows you to control the speed and direction of two DC motors simultaneously.

===== Pin Connections =====
* VCC: 5V power supply
* GND: Ground
* ENA: Enable pin for Motor A (PWM control)
* IN1, IN2: Control pins for Motor A direction
* IN3, IN4: Control pins for Motor B direction
* ENB: Enable pin for Motor B (PWM control)
* OUT1, OUT2: Motor A connections
* OUT3, OUT4: Motor B connections

===== Tutorial =====
https://naylampmechatronics.com/blog/11_tutorial-de-uso-del-modulo-l298n.html


===== Pin Connections =====
{{{code: lang="text" linenumbers="True"
L298N Controlador    →    Raspberry Pi Physical Pin
├── IN1              →    GPIO 17 (Pin 11)
├── IN2              →    GPIO 27 (Pin 13)
├── IN3              →    GPIO 22 (Pin 15)
├── IN4              →    GPIO 23 (Pin 16)
├── ENA              →    GPIO 18 (Pin 12)
├── ENB              →    GPIO 10 (Pin 19)
└── GND              →    GND (Pin 6, 9, 14, 20, 25, 30, 34, 39)
}}}

===== Basic Control Code =====
{{{code: lang="python" linenumbers="True"
import RPi.GPIO as GPIO
import time

# Pin definitions
ENA = 18  # PWM pin for motor A - Physical Pin 12
IN1 = 17  # Physical Pin 11
IN2 = 27  # Physical Pin 13
IN3 = 22  # Physical Pin 15
IN4 = 23  # Physical Pin 16
ENB = 10  # PWM pin for motor B - Physical Pin 19

def setup():
    GPIO.setmode(GPIO.BCM)
    GPIO.setup([ENA, IN1, IN2, IN3, IN4, ENB], GPIO.OUT)
    
    # Setup PWM
    pwm_a = GPIO.PWM(ENA, 1000)  # 1000 Hz frequency
    pwm_b = GPIO.PWM(ENB, 1000)
    pwm_a.start(0)  # Start with 0% duty cycle
    pwm_b.start(0)
    
    return pwm_a, pwm_b

def forward(pwm_a, pwm_b, speed=50):
    GPIO.output(IN1, GPIO.HIGH)
    GPIO.output(IN2, GPIO.LOW)
    GPIO.output(IN3, GPIO.HIGH)
    GPIO.output(IN4, GPIO.LOW)
    pwm_a.ChangeDutyCycle(speed)
    pwm_b.ChangeDutyCycle(speed)

def backward(pwm_a, pwm_b, speed=50):
    GPIO.output(IN1, GPIO.LOW)
    GPIO.output(IN2, GPIO.HIGH)
    GPIO.output(IN3, GPIO.LOW)
    GPIO.output(IN4, GPIO.HIGH)
    pwm_a.ChangeDutyCycle(speed)
    pwm_b.ChangeDutyCycle(speed)

def stop(pwm_a, pwm_b):
    pwm_a.ChangeDutyCycle(0)
    pwm_b.ChangeDutyCycle(0)
}}}

===== Status =====
* Tutorial link saved
* Pin mapping defined with physical pin numbers
* Basic control code ready with correct GPIO assignments
* GPIO 24 changed to GPIO 10 for ENB (documentation updated)
* Ready for integration with main project
